{
  "name": "Scheduled Status Check",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        240,
        300
      ],
      "id": "schedule-trigger-001",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "HhIjOZoqh2MciLvC",
          "mode": "list",
          "cachedResultName": "domains",
          "cachedResultUrl": "/projects/GZaAImtP0U41Lgwk/datatables/HhIjOZoqh2MciLvC"
        },
        "returnAll": true
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        460,
        300
      ],
      "id": "read-domains-001",
      "name": "Read All Domains"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Extract the registrable base domain from a URL (eTLD+1)\nfunction getBaseDomain(urlOrHostname) {\n  try {\n    let hostname;\n    const urlMatch = urlOrHostname.match(/https?:\\/\\/([^\\/:]+)/i);\n    hostname = urlMatch ? urlMatch[1] : urlOrHostname;\n    hostname = hostname.replace(/^www\\./, '').toLowerCase();\n    const parts = hostname.split('.');\n    const knownSLDs = ['co', 'com', 'org', 'net', 'gov', 'edu', 'ac'];\n    if (parts.length >= 3 && knownSLDs.includes(parts[parts.length - 2])) {\n      return parts.slice(-3).join('.');\n    }\n    return parts.slice(-2).join('.');\n  } catch { return null; }\n}\n\n// Well-known URL shortener domains to ignore\nconst SHORTENER_DOMAINS = ['wp.me', 'bit.ly', 'goo.gl', 't.co', 'tinyurl.com', 'ow.ly', 'is.gd'];\n\nlet rdapCount = 0;\n\nfor (let idx = 0; idx < items.length; idx++) {\n  const item = items[idx];\n  const domain = item.json.domain;\n  const isExcluded = item.json.excluded === true || item.json.excluded === 'true';\n\n  if (isExcluded) {\n    results.push({\n      json: {\n        domain,\n        httpStatus: item.json.httpStatus || 0,\n        statusCategory: item.json.statusCategory || 'unknown',\n        registrar: item.json.registrar || 'Unknown',\n        expirationDate: item.json.expirationDate || null,\n        renewalStatus: item.json.renewalStatus || 'unknown',\n        daysUntilExpiration: item.json.daysUntilExpiration || null,\n        lastChecked: item.json.lastChecked || new Date().toISOString()\n      }\n    });\n    continue;\n  }\n\n  let httpStatus = 0;\n  let statusCategory = 'unknown';\n  let redirectTo = '';\n\n  try {\n    const response = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://${domain}`,\n      followRedirect: true,\n      timeout: 10000,\n      returnFullResponse: true,\n      ignoreHttpStatusErrors: true,\n    });\n    httpStatus = response.statusCode || 0;\n\n    if (httpStatus >= 300 && httpStatus < 400) {\n      statusCategory = 'redirect';\n    } else if (httpStatus >= 200 && httpStatus < 300) {\n      statusCategory = 'healthy';\n      const headers = response.headers || {};\n      const body = typeof response.body === 'string' ? response.body.substring(0, 5000) : '';\n      const myBase = getBaseDomain(domain);\n\n      // Method 1: Check HTML canonical link (most reliable)\n      if (body) {\n        const canonicalMatch = body.match(/<link[^>]+rel=[\"']canonical[\"'][^>]+href=[\"']([^\"']+)[\"']/i)\n          || body.match(/<link[^>]+href=[\"']([^\"']+)[\"'][^>]+rel=[\"']canonical[\"']/i);\n        if (canonicalMatch) {\n          const canonBase = getBaseDomain(canonicalMatch[1]);\n          if (canonBase && canonBase !== myBase && !SHORTENER_DOMAINS.includes(canonBase)) {\n            statusCategory = 'redirect';\n            httpStatus = 301;\n            redirectTo = canonBase;\n          }\n        }\n      }\n\n      // Method 2: Check Link header \u2014 only look at rel=canonical entries\n      if (statusCategory === 'healthy') {\n        const linkHeader = headers.link || headers.Link || '';\n        if (linkHeader) {\n          // Parse each comma-separated entry individually\n          const entries = linkHeader.split(',');\n          for (const entry of entries) {\n            // Only check rel=canonical in Link header (not shortlink/alternate)\n            if (/rel=[\"']?canonical[\"']?/i.test(entry)) {\n              const urlM = entry.match(/<([^>]+)>/);\n              if (urlM) {\n                const linkBase = getBaseDomain(urlM[1]);\n                if (linkBase && linkBase !== myBase && !SHORTENER_DOMAINS.includes(linkBase)) {\n                  statusCategory = 'redirect';\n                  httpStatus = 301;\n                  redirectTo = linkBase;\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // Method 3: Check meta refresh\n      if (statusCategory === 'healthy' && body) {\n        const metaRefresh = body.match(/<meta[^>]+http-equiv=[\"']refresh[\"'][^>]+url=[\"']?([^\"';\\s>]+)/i);\n        if (metaRefresh) {\n          const refreshBase = getBaseDomain(metaRefresh[1]);\n          if (refreshBase && refreshBase !== myBase && !SHORTENER_DOMAINS.includes(refreshBase)) {\n            statusCategory = 'redirect';\n            httpStatus = 301;\n            redirectTo = refreshBase;\n          }\n        }\n      }\n    } else {\n      statusCategory = 'down';\n    }\n  } catch (e) {\n    httpStatus = 0;\n    statusCategory = 'down';\n  }\n\n  // --- RDAP Lookup ---\n  let expirationDate = item.json.expirationDate || null;\n  let registrar = item.json.registrar || 'Unknown';\n\n  if (expirationDate && (String(expirationDate).includes('{{') || String(expirationDate).includes('$json'))) {\n    expirationDate = null;\n  }\n\n  if (!expirationDate) {\n    try {\n      if (rdapCount > 0) await sleep(300);\n      rdapCount++;\n\n      const rdapResponse = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `https://rdap.org/domain/${domain}`,\n        followRedirect: true,\n        timeout: 10000,\n        json: true,\n      });\n\n      if (rdapResponse.events && Array.isArray(rdapResponse.events)) {\n        const expirationEvent = rdapResponse.events.find(e => e.eventAction === 'expiration');\n        if (expirationEvent && expirationEvent.eventDate) {\n          expirationDate = expirationEvent.eventDate;\n        }\n      }\n\n      if (rdapResponse.entities && Array.isArray(rdapResponse.entities)) {\n        const registrarEntity = rdapResponse.entities.find(\n          e => e.roles && Array.isArray(e.roles) && e.roles.includes('registrar')\n        );\n        if (registrarEntity && registrarEntity.vcardArray && registrarEntity.vcardArray[1]) {\n          const fn = registrarEntity.vcardArray[1].find(v => v[0] === 'fn');\n          if (fn && fn[3]) registrar = fn[3];\n        }\n      }\n    } catch (e) {}\n  }\n\n  let renewalStatus = 'unknown';\n  let daysUntilExpiration = null;\n  if (expirationDate) {\n    const now = new Date();\n    const expDate = new Date(expirationDate);\n    daysUntilExpiration = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));\n    if (expDate < now) renewalStatus = 'expired';\n    else if (expDate < new Date(now.getTime() + 30*24*60*60*1000)) renewalStatus = 'warning';\n    else renewalStatus = 'healthy';\n  }\n\n  results.push({\n    json: {\n      domain, httpStatus,\n      statusCategory: redirectTo ? 'redirect:' + redirectTo : statusCategory,\n      registrar,\n      expirationDate, renewalStatus, daysUntilExpiration,\n      lastChecked: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ],
      "id": "check-status-001",
      "name": "Check Status & RDAP"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "HhIjOZoqh2MciLvC",
          "mode": "list",
          "cachedResultName": "domains",
          "cachedResultUrl": "/projects/GZaAImtP0U41Lgwk/datatables/HhIjOZoqh2MciLvC"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "domain",
              "condition": "eq",
              "keyValue": "={{ $json.domain }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "domain": "={{ $json.domain }}",
            "httpStatus": "={{ $json.httpStatus }}",
            "statusCategory": "={{ $json.statusCategory }}",
            "registrar": "={{ $json.registrar }}",
            "expirationDate": "={{ $json.expirationDate }}",
            "renewalStatus": "={{ $json.renewalStatus }}",
            "daysUntilExpiration": "={{ $json.daysUntilExpiration }}",
            "lastChecked": "={{ $json.lastChecked }}"
          },
          "matchingColumns": [
            "domain"
          ],
          "schema": [
            {
              "id": "domain",
              "displayName": "domain",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "httpStatus",
              "displayName": "httpStatus",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "statusCategory",
              "displayName": "statusCategory",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "registrar",
              "displayName": "registrar",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expirationDate",
              "displayName": "expirationDate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "renewalStatus",
              "displayName": "renewalStatus",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "daysUntilExpiration",
              "displayName": "daysUntilExpiration",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "lastChecked",
              "displayName": "lastChecked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        900,
        300
      ],
      "id": "update-table-001",
      "name": "Update Status in Table"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "run-status-check",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        240,
        500
      ],
      "id": "manual-trigger-001",
      "name": "Manual Trigger Webhook",
      "webhookId": "run-status-check-wh"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Read All Domains",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read All Domains": {
      "main": [
        [
          {
            "node": "Check Status & RDAP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Status & RDAP": {
      "main": [
        [
          {
            "node": "Update Status in Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger Webhook": {
      "main": [
        [
          {
            "node": "Read All Domains",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}