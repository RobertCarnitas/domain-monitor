{
  "name": "Scheduled Status Check",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        240,
        300
      ],
      "id": "schedule-trigger-001",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "HhIjOZoqh2MciLvC",
          "mode": "list",
          "cachedResultName": "domains",
          "cachedResultUrl": "/projects/GZaAImtP0U41Lgwk/datatables/HhIjOZoqh2MciLvC"
        },
        "returnAll": true
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        460,
        300
      ],
      "id": "read-domains-001",
      "name": "Read All Domains"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction getBaseDomain(urlOrHostname) {\n  try {\n    let hostname;\n    const urlMatch = urlOrHostname.match(/https?:\\/\\/([^\\/:]+)/i);\n    hostname = urlMatch ? urlMatch[1] : urlOrHostname;\n    hostname = hostname.replace(/^www\\./, '').toLowerCase();\n    const parts = hostname.split('.');\n    const knownSLDs = ['co', 'com', 'org', 'net', 'gov', 'edu', 'ac'];\n    if (parts.length >= 3 && knownSLDs.includes(parts[parts.length - 2])) {\n      return parts.slice(-3).join('.');\n    }\n    return parts.slice(-2).join('.');\n  } catch { return null; }\n}\n\nconst SHORTENER_DOMAINS = ['wp.me', 'bit.ly', 'goo.gl', 't.co', 'tinyurl.com', 'ow.ly', 'is.gd'];\n\n// --- Extract Slack config from data table rows ---\nlet slackWebhookUrl = '';\nconst configItem = items.find(i => i.json.domain === '__slack_config__');\nif (configItem) {\n  slackWebhookUrl = configItem.json.statusCategory || '';\n  const enabled = configItem.json.httpStatus;\n  if (enabled === 0 || enabled === '0') slackWebhookUrl = '';\n}\n\nconst alertsDown = [];\nconst alertsRedirect = [];\nconst alertsExpiring = [];\n\nlet rdapCount = 0;\n\nfor (let idx = 0; idx < items.length; idx++) {\n  const item = items[idx];\n  const domain = item.json.domain;\n\n  // Skip config row\n  if (domain === '__slack_config__') {\n    results.push({ json: item.json });\n    continue;\n  }\n\n  const isExcluded = item.json.excluded === true || item.json.excluded === 'true';\n\n  if (isExcluded) {\n    results.push({\n      json: {\n        domain,\n        httpStatus: item.json.httpStatus || 0,\n        statusCategory: item.json.statusCategory || 'unknown',\n        registrar: item.json.registrar || 'Unknown',\n        expirationDate: item.json.expirationDate || null,\n        renewalStatus: item.json.renewalStatus || 'unknown',\n        daysUntilExpiration: item.json.daysUntilExpiration || null,\n        lastChecked: item.json.lastChecked || new Date().toISOString()\n      }\n    });\n    continue;\n  }\n\n  let httpStatus = 0;\n  let statusCategory = 'unknown';\n  let redirectTo = '';\n\n  try {\n    const response = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://${domain}`,\n      followRedirect: true,\n      timeout: 10000,\n      returnFullResponse: true,\n      ignoreHttpStatusErrors: true,\n    });\n    httpStatus = response.statusCode || 0;\n\n    if (httpStatus >= 300 && httpStatus < 400) {\n      statusCategory = 'redirect';\n    } else if (httpStatus >= 200 && httpStatus < 300) {\n      statusCategory = 'healthy';\n      const headers = response.headers || {};\n      const body = typeof response.body === 'string' ? response.body.substring(0, 5000) : '';\n      const myBase = getBaseDomain(domain);\n\n      if (body) {\n        const canonicalMatch = body.match(/<link[^>]+rel=[\"']canonical[\"'][^>]+href=[\"']([^\"']+)[\"']/i)\n          || body.match(/<link[^>]+href=[\"']([^\"']+)[\"'][^>]+rel=[\"']canonical[\"']/i);\n        if (canonicalMatch) {\n          const canonBase = getBaseDomain(canonicalMatch[1]);\n          if (canonBase && canonBase !== myBase && !SHORTENER_DOMAINS.includes(canonBase)) {\n            statusCategory = 'redirect';\n            httpStatus = 301;\n            redirectTo = canonBase;\n          }\n        }\n      }\n\n      if (statusCategory === 'healthy') {\n        const linkHeader = headers.link || headers.Link || '';\n        if (linkHeader) {\n          const entries = linkHeader.split(',');\n          for (const entry of entries) {\n            if (/rel=[\"']?canonical[\"']?/i.test(entry)) {\n              const urlM = entry.match(/<([^>]+)>/);\n              if (urlM) {\n                const linkBase = getBaseDomain(urlM[1]);\n                if (linkBase && linkBase !== myBase && !SHORTENER_DOMAINS.includes(linkBase)) {\n                  statusCategory = 'redirect';\n                  httpStatus = 301;\n                  redirectTo = linkBase;\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (statusCategory === 'healthy' && body) {\n        const metaRefresh = body.match(/<meta[^>]+http-equiv=[\"']refresh[\"'][^>]+url=[\"']?([^\"';\\s>]+)/i);\n        if (metaRefresh) {\n          const refreshBase = getBaseDomain(metaRefresh[1]);\n          if (refreshBase && refreshBase !== myBase && !SHORTENER_DOMAINS.includes(refreshBase)) {\n            statusCategory = 'redirect';\n            httpStatus = 301;\n            redirectTo = refreshBase;\n          }\n        }\n      }\n    } else {\n      statusCategory = 'down';\n    }\n  } catch (e) {\n    httpStatus = 0;\n    statusCategory = 'down';\n  }\n\n  // --- RDAP Lookup ---\n  let expirationDate = item.json.expirationDate || null;\n  let registrar = item.json.registrar || 'Unknown';\n\n  if (expirationDate && (String(expirationDate).includes('{{') || String(expirationDate).includes('$json'))) {\n    expirationDate = null;\n  }\n\n  if (!expirationDate) {\n    try {\n      if (rdapCount > 0) await sleep(300);\n      rdapCount++;\n\n      const rdapResponse = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `https://rdap.org/domain/${domain}`,\n        followRedirect: true,\n        timeout: 10000,\n        json: true,\n      });\n\n      if (rdapResponse.events && Array.isArray(rdapResponse.events)) {\n        const expirationEvent = rdapResponse.events.find(e => e.eventAction === 'expiration');\n        if (expirationEvent && expirationEvent.eventDate) {\n          expirationDate = expirationEvent.eventDate;\n        }\n      }\n\n      if (rdapResponse.entities && Array.isArray(rdapResponse.entities)) {\n        const registrarEntity = rdapResponse.entities.find(\n          e => e.roles && Array.isArray(e.roles) && e.roles.includes('registrar')\n        );\n        if (registrarEntity && registrarEntity.vcardArray && registrarEntity.vcardArray[1]) {\n          const fn = registrarEntity.vcardArray[1].find(v => v[0] === 'fn');\n          if (fn && fn[3]) registrar = fn[3];\n        }\n      }\n    } catch (e) {}\n  }\n\n  let renewalStatus = 'unknown';\n  let daysUntilExpiration = null;\n  if (expirationDate) {\n    const now = new Date();\n    const expDate = new Date(expirationDate);\n    daysUntilExpiration = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));\n    if (expDate < now) renewalStatus = 'expired';\n    else if (expDate < new Date(now.getTime() + 30*24*60*60*1000)) renewalStatus = 'warning';\n    else renewalStatus = 'healthy';\n  }\n\n  // --- CHANGE DETECTION FOR ALERTS ---\n  if (slackWebhookUrl) {\n    const prevRaw = item.json.statusCategory || 'unknown';\n    const prevBase = prevRaw.startsWith('redirect:') ? 'redirect' : prevRaw;\n    const newBase = redirectTo ? 'redirect' : statusCategory;\n\n    if (newBase === 'down' && (prevBase === 'healthy' || prevBase === 'redirect')) {\n      alertsDown.push({ domain, httpStatus, previousStatus: prevBase });\n    }\n    if (newBase === 'redirect' && prevBase === 'healthy') {\n      alertsRedirect.push({ domain, redirectTo: redirectTo || 'unknown' });\n    }\n\n    if (daysUntilExpiration !== null && daysUntilExpiration > 0 && daysUntilExpiration <= 7) {\n      const prevDays = item.json.daysUntilExpiration;\n      if (prevDays !== null && prevDays !== undefined) {\n        const prev = Number(prevDays);\n        if (!isNaN(prev)) {\n          if (prev > 7 && daysUntilExpiration <= 7) {\n            alertsExpiring.push({ domain, daysUntilExpiration, milestone: 7 });\n          } else if (prev > 3 && daysUntilExpiration <= 3) {\n            alertsExpiring.push({ domain, daysUntilExpiration, milestone: 3 });\n          } else if (prev > 1 && daysUntilExpiration <= 1) {\n            alertsExpiring.push({ domain, daysUntilExpiration, milestone: 1 });\n          }\n        }\n      }\n    }\n  }\n\n  results.push({\n    json: {\n      domain, httpStatus,\n      statusCategory: redirectTo ? 'redirect:' + redirectTo : statusCategory,\n      registrar,\n      expirationDate, renewalStatus, daysUntilExpiration,\n      lastChecked: new Date().toISOString()\n    }\n  });\n}\n\n// --- SEND SLACK ALERTS ---\nconst totalAlerts = alertsDown.length + alertsRedirect.length + alertsExpiring.length;\nif (totalAlerts > 0 && slackWebhookUrl) {\n  const blocks = [];\n  const MAX_PER_SECTION = 15;\n\n  blocks.push({\n    type: 'header',\n    text: { type: 'plain_text', text: `Domain Monitor Alert \\u2014 ${totalAlerts} issue${totalAlerts > 1 ? 's' : ''} detected`, emoji: true }\n  });\n\n  if (alertsDown.length > 0) {\n    blocks.push({ type: 'divider' });\n    blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*:red_circle: Sites Down*' } });\n    const shown = alertsDown.slice(0, MAX_PER_SECTION);\n    for (const a of shown) {\n      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `*${a.domain}*\\nHTTP ${a.httpStatus || 'unreachable'} \\u2014 was _${a.previousStatus}_` } });\n    }\n    if (alertsDown.length > MAX_PER_SECTION) {\n      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_...and ${alertsDown.length - MAX_PER_SECTION} more_` }] });\n    }\n  }\n\n  if (alertsRedirect.length > 0) {\n    blocks.push({ type: 'divider' });\n    blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*:large_yellow_circle: New Redirects*' } });\n    const shown = alertsRedirect.slice(0, MAX_PER_SECTION);\n    for (const a of shown) {\n      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `*${a.domain}*\\nNow redirects to _${a.redirectTo}_` } });\n    }\n    if (alertsRedirect.length > MAX_PER_SECTION) {\n      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_...and ${alertsRedirect.length - MAX_PER_SECTION} more_` }] });\n    }\n  }\n\n  if (alertsExpiring.length > 0) {\n    blocks.push({ type: 'divider' });\n    blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*:warning: Domains Expiring*' } });\n    const shown = alertsExpiring.slice(0, MAX_PER_SECTION);\n    for (const a of shown) {\n      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `*${a.domain}*\\n${a.daysUntilExpiration} day${a.daysUntilExpiration !== 1 ? 's' : ''} until expiration` } });\n    }\n    if (alertsExpiring.length > MAX_PER_SECTION) {\n      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_...and ${alertsExpiring.length - MAX_PER_SECTION} more_` }] });\n    }\n  }\n\n  blocks.push({ type: 'divider' });\n  blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `Checked at ${new Date().toISOString()} | ${results.length} domains monitored` }] });\n\n  const attachments = [];\n  if (alertsDown.length > 0) {\n    attachments.push({ color: '#e74c3c', text: `${alertsDown.length} site${alertsDown.length > 1 ? 's' : ''} went down: ${alertsDown.map(a => a.domain).join(', ')}` });\n  }\n  if (alertsRedirect.length > 0) {\n    attachments.push({ color: '#f39c12', text: `${alertsRedirect.length} new redirect${alertsRedirect.length > 1 ? 's' : ''}: ${alertsRedirect.map(a => a.domain).join(', ')}` });\n  }\n  if (alertsExpiring.length > 0) {\n    attachments.push({ color: '#f39c12', text: `${alertsExpiring.length} domain${alertsExpiring.length > 1 ? 's' : ''} expiring soon: ${alertsExpiring.map(a => a.domain + ' (' + a.daysUntilExpiration + 'd)').join(', ')}` });\n  }\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: slackWebhookUrl,\n      body: { blocks, attachments },\n      headers: { 'Content-Type': 'application/json' },\n    });\n  } catch (slackErr) {\n    // Don't fail the workflow if Slack notification fails\n  }\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ],
      "id": "check-status-001",
      "name": "Check Status & RDAP"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "HhIjOZoqh2MciLvC",
          "mode": "list",
          "cachedResultName": "domains",
          "cachedResultUrl": "/projects/GZaAImtP0U41Lgwk/datatables/HhIjOZoqh2MciLvC"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "domain",
              "condition": "eq",
              "keyValue": "={{ $json.domain }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "domain": "={{ $json.domain }}",
            "httpStatus": "={{ $json.httpStatus }}",
            "statusCategory": "={{ $json.statusCategory }}",
            "registrar": "={{ $json.registrar }}",
            "expirationDate": "={{ $json.expirationDate }}",
            "renewalStatus": "={{ $json.renewalStatus }}",
            "daysUntilExpiration": "={{ $json.daysUntilExpiration }}",
            "lastChecked": "={{ $json.lastChecked }}"
          },
          "matchingColumns": [
            "domain"
          ],
          "schema": [
            {
              "id": "domain",
              "displayName": "domain",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "httpStatus",
              "displayName": "httpStatus",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "statusCategory",
              "displayName": "statusCategory",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "registrar",
              "displayName": "registrar",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expirationDate",
              "displayName": "expirationDate",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "renewalStatus",
              "displayName": "renewalStatus",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "daysUntilExpiration",
              "displayName": "daysUntilExpiration",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "lastChecked",
              "displayName": "lastChecked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        900,
        300
      ],
      "id": "update-table-001",
      "name": "Update Status in Table"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "run-status-check",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        240,
        500
      ],
      "id": "manual-trigger-001",
      "name": "Manual Trigger Webhook",
      "webhookId": "run-status-check-wh"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Read All Domains",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read All Domains": {
      "main": [
        [
          {
            "node": "Check Status & RDAP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Status & RDAP": {
      "main": [
        [
          {
            "node": "Update Status in Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger Webhook": {
      "main": [
        [
          {
            "node": "Read All Domains",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}