{
  "name": "Quick Status Check",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [240, 300],
      "id": "schedule-trigger-001",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "HhIjOZoqh2MciLvC",
          "mode": "list",
          "cachedResultName": "domains",
          "cachedResultUrl": "/projects/GZaAImtP0U41Lgwk/datatables/HhIjOZoqh2MciLvC"
        },
        "returnAll": true
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [460, 300],
      "id": "read-domains-001",
      "name": "Read All Domains"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfunction getBaseDomain(urlOrHostname) {\n  try {\n    let hostname;\n    const urlMatch = urlOrHostname.match(/https?:\\/\\/([^\\/:]+)/i);\n    hostname = urlMatch ? urlMatch[1] : urlOrHostname;\n    hostname = hostname.replace(/^www\\./, '').toLowerCase();\n    const parts = hostname.split('.');\n    const knownSLDs = ['co', 'com', 'org', 'net', 'gov', 'edu', 'ac'];\n    if (parts.length >= 3 && knownSLDs.includes(parts[parts.length - 2])) {\n      return parts.slice(-3).join('.');\n    }\n    return parts.slice(-2).join('.');\n  } catch { return null; }\n}\n\nconst SHORTENER_DOMAINS = ['wp.me', 'bit.ly', 'goo.gl', 't.co', 'tinyurl.com', 'ow.ly', 'is.gd'];\n\n// --- Extract Slack config from data table rows ---\nlet slackWebhookUrl = '';\nconst configItem = items.find(i => i.json.domain === '__slack_config__');\nif (configItem) {\n  slackWebhookUrl = configItem.json.statusCategory || '';\n  const enabled = configItem.json.httpStatus;\n  if (enabled === 0 || enabled === '0') slackWebhookUrl = '';\n}\n\nconst alertsDown = [];\nconst alertsRedirect = [];\nconst alertsRecovery = [];\n\nfor (let idx = 0; idx < items.length; idx++) {\n  const item = items[idx];\n  const domain = item.json.domain;\n\n  // Skip config row — pass through unchanged\n  if (domain === '__slack_config__') {\n    results.push({ json: item.json });\n    continue;\n  }\n\n  const isExcluded = item.json.excluded === true || item.json.excluded === 'true';\n\n  if (isExcluded) {\n    results.push({\n      json: {\n        domain,\n        httpStatus: item.json.httpStatus || 0,\n        statusCategory: item.json.statusCategory || 'unknown',\n        registrar: item.json.registrar || 'Unknown',\n        expirationDate: item.json.expirationDate || null,\n        renewalStatus: item.json.renewalStatus || 'unknown',\n        daysUntilExpiration: item.json.daysUntilExpiration || null,\n        lastChecked: item.json.lastChecked || new Date().toISOString(),\n        triageStatus: item.json.triageStatus || ''\n      }\n    });\n    continue;\n  }\n\n  let httpStatus = 0;\n  let statusCategory = 'unknown';\n  let redirectTo = '';\n\n  // Helper: make one HTTP check attempt\n  async function checkOnce(d) {\n    const resp = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://${d}`,\n      followRedirect: false,\n      timeout: 5000,\n      returnFullResponse: true,\n      ignoreHttpStatusErrors: true,\n    });\n    return resp;\n  }\n\n  try {\n    // STEP 1: Non-following request to detect HTTP-level redirects (301/302)\n    let noFollowResponse;\n    try {\n      noFollowResponse = await checkOnce.call(this, domain);\n    } catch (firstErr) {\n      // First attempt failed (timeout/network) — retry once immediately\n      // This prevents false 'down' alerts from transient network blips\n      noFollowResponse = await checkOnce.call(this, domain);\n    }\n    httpStatus = noFollowResponse.statusCode || 0;\n\n    if (httpStatus >= 300 && httpStatus < 400) {\n      // HTTP-level redirect detected — check where it goes\n      statusCategory = 'redirect';\n      const location = (noFollowResponse.headers || {}).location || '';\n      if (location) {\n        const locBase = getBaseDomain(location);\n        const myBase = getBaseDomain(domain);\n        if (locBase && locBase !== myBase && !SHORTENER_DOMAINS.includes(locBase)) {\n          redirectTo = locBase;\n        }\n      }\n    } else if (httpStatus >= 200 && httpStatus < 300) {\n      // STEP 2: No HTTP redirect — check body for canonical/meta-refresh redirects\n      statusCategory = 'healthy';\n      const headers = noFollowResponse.headers || {};\n      const body = typeof noFollowResponse.body === 'string' ? noFollowResponse.body.substring(0, 50000) : '';\n      const myBase = getBaseDomain(domain);\n\n      if (body) {\n        const canonicalMatch = body.match(/<link[^>]+rel=[\"']canonical[\"'][^>]+href=[\"']([^\"']+)[\"']/i)\n          || body.match(/<link[^>]+href=[\"']([^\"']+)[\"'][^>]+rel=[\"']canonical[\"']/i);\n        if (canonicalMatch) {\n          const canonBase = getBaseDomain(canonicalMatch[1]);\n          if (canonBase && canonBase !== myBase && !SHORTENER_DOMAINS.includes(canonBase)) {\n            statusCategory = 'redirect';\n            httpStatus = 301;\n            redirectTo = canonBase;\n          }\n        }\n      }\n\n      if (statusCategory === 'healthy') {\n        const linkHeader = headers.link || headers.Link || '';\n        if (linkHeader) {\n          const entries = linkHeader.split(',');\n          for (const entry of entries) {\n            if (/rel=[\"']?canonical[\"']?/i.test(entry)) {\n              const urlM = entry.match(/<([^>]+)>/);\n              if (urlM) {\n                const linkBase = getBaseDomain(urlM[1]);\n                if (linkBase && linkBase !== myBase && !SHORTENER_DOMAINS.includes(linkBase)) {\n                  statusCategory = 'redirect';\n                  httpStatus = 301;\n                  redirectTo = linkBase;\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (statusCategory === 'healthy' && body) {\n        const metaRefresh = body.match(/<meta[^>]+http-equiv=[\"']refresh[\"'][^>]+url=[\"']?([^\"';\\s>]+)/i);\n        if (metaRefresh) {\n          const refreshBase = getBaseDomain(metaRefresh[1]);\n          if (refreshBase && refreshBase !== myBase && !SHORTENER_DOMAINS.includes(refreshBase)) {\n            statusCategory = 'redirect';\n            httpStatus = 301;\n            redirectTo = refreshBase;\n          }\n        }\n      }\n    } else {\n      statusCategory = 'down';\n    }\n  } catch (e) {\n    httpStatus = 0;\n    statusCategory = 'down';\n  }\n\n  // --- CHANGE DETECTION FOR ALERTS (HTTP status changes only) ---\n  if (slackWebhookUrl) {\n    const prevRaw = item.json.statusCategory || 'unknown';\n    const prevBase = prevRaw.startsWith('redirect:') ? 'redirect' : prevRaw;\n    const newBase = redirectTo ? 'redirect' : statusCategory;\n\n    if (newBase === 'down' && (prevBase === 'healthy' || prevBase === 'redirect')) {\n      alertsDown.push({ domain, httpStatus, previousStatus: prevBase });\n    }\n    if (newBase === 'redirect' && prevBase === 'healthy') {\n      alertsRedirect.push({ domain, redirectTo: redirectTo || 'unknown' });\n    }\n    if (newBase === 'healthy' && (prevBase === 'down' || prevBase === 'redirect')) {\n      alertsRecovery.push({ domain, recoveredFrom: prevBase });\n    }\n  }\n\n  // --- Pass through RDAP fields unchanged from data table ---\n  results.push({\n    json: {\n      domain,\n      httpStatus,\n      statusCategory: redirectTo ? 'redirect:' + redirectTo : statusCategory,\n      registrar: item.json.registrar || 'Unknown',\n      expirationDate: item.json.expirationDate || null,\n      renewalStatus: item.json.renewalStatus || 'unknown',\n      daysUntilExpiration: item.json.daysUntilExpiration || null,\n      lastChecked: new Date().toISOString(),\n      triageStatus: item.json.triageStatus || ''\n    }\n  });\n}\n\n// --- SEND SLACK ALERTS (down, redirect, recovery only) ---\nconst totalAlerts = alertsDown.length + alertsRedirect.length + alertsRecovery.length;\nif (totalAlerts > 0 && slackWebhookUrl) {\n  const blocks = [];\n  const MAX_PER_SECTION = 15;\n\n  blocks.push({\n    type: 'header',\n    text: { type: 'plain_text', text: `Domain Monitor Alert \\u2014 ${totalAlerts} change${totalAlerts > 1 ? 's' : ''} detected`, emoji: true }\n  });\n\n  if (alertsDown.length > 0) {\n    blocks.push({ type: 'divider' });\n    blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*:red_circle: Sites Down*' } });\n    const shown = alertsDown.slice(0, MAX_PER_SECTION);\n    for (const a of shown) {\n      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `*${a.domain}*\\nHTTP ${a.httpStatus || 'unreachable'} \\u2014 was _${a.previousStatus}_` } });\n    }\n    if (alertsDown.length > MAX_PER_SECTION) {\n      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_...and ${alertsDown.length - MAX_PER_SECTION} more_` }] });\n    }\n  }\n\n  if (alertsRedirect.length > 0) {\n    blocks.push({ type: 'divider' });\n    blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*:large_yellow_circle: New Redirects*' } });\n    const shown = alertsRedirect.slice(0, MAX_PER_SECTION);\n    for (const a of shown) {\n      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `*${a.domain}*\\nNow redirects to _${a.redirectTo}_` } });\n    }\n    if (alertsRedirect.length > MAX_PER_SECTION) {\n      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_...and ${alertsRedirect.length - MAX_PER_SECTION} more_` }] });\n    }\n  }\n\n  if (alertsRecovery.length > 0) {\n    blocks.push({ type: 'divider' });\n    blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*:large_green_circle: Sites Recovered*' } });\n    const shownR = alertsRecovery.slice(0, MAX_PER_SECTION);\n    for (const a of shownR) {\n      const msg = a.recoveredFrom === 'down' ? 'Back online' : 'No longer redirecting';\n      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `*${a.domain}*\\n${msg}` } });\n    }\n    if (alertsRecovery.length > MAX_PER_SECTION) {\n      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_...and ${alertsRecovery.length - MAX_PER_SECTION} more_` }] });\n    }\n  }\n\n  blocks.push({ type: 'divider' });\n  blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `Checked at ${new Date().toISOString()} | ${results.length} domains monitored` }] });\n\n  const attachments = [];\n  if (alertsDown.length > 0) {\n    attachments.push({ color: '#e74c3c', text: `${alertsDown.length} site${alertsDown.length > 1 ? 's' : ''} went down: ${alertsDown.map(a => a.domain).join(', ')}` });\n  }\n  if (alertsRedirect.length > 0) {\n    attachments.push({ color: '#f39c12', text: `${alertsRedirect.length} new redirect${alertsRedirect.length > 1 ? 's' : ''}: ${alertsRedirect.map(a => a.domain).join(', ')}` });\n  }\n  if (alertsRecovery.length > 0) {\n    attachments.push({ color: '#2ecc71', text: `${alertsRecovery.length} domain${alertsRecovery.length > 1 ? 's' : ''} recovered: ${alertsRecovery.map(a => a.domain).join(', ')}` });\n  }\n\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: slackWebhookUrl,\n      body: { blocks, attachments },\n      headers: { 'Content-Type': 'application/json' },\n    });\n  } catch (slackErr) {\n    // Don't fail the workflow if Slack notification fails\n  }\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "id": "check-status-001",
      "name": "Quick HTTP Check"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "HhIjOZoqh2MciLvC",
          "mode": "list",
          "cachedResultName": "domains",
          "cachedResultUrl": "/projects/GZaAImtP0U41Lgwk/datatables/HhIjOZoqh2MciLvC"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "domain",
              "condition": "eq",
              "keyValue": "={{ $json.domain }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "domain": "={{ $json.domain }}",
            "httpStatus": "={{ $json.httpStatus }}",
            "statusCategory": "={{ $json.statusCategory }}",
            "registrar": "={{ $json.registrar }}",
            "expirationDate": "={{ $json.expirationDate }}",
            "renewalStatus": "={{ $json.renewalStatus }}",
            "daysUntilExpiration": "={{ $json.daysUntilExpiration }}",
            "lastChecked": "={{ $json.lastChecked }}",
            "triageStatus": "={{ $json.triageStatus }}"
          },
          "matchingColumns": ["domain"],
          "schema": [
            { "id": "domain", "displayName": "domain", "required": false, "defaultMatch": true, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "httpStatus", "displayName": "httpStatus", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "statusCategory", "displayName": "statusCategory", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "registrar", "displayName": "registrar", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "expirationDate", "displayName": "expirationDate", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "renewalStatus", "displayName": "renewalStatus", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "daysUntilExpiration", "displayName": "daysUntilExpiration", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "lastChecked", "displayName": "lastChecked", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false },
            { "id": "triageStatus", "displayName": "triageStatus", "required": false, "defaultMatch": false, "display": true, "type": "string", "readOnly": false, "removed": false }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [900, 300],
      "id": "update-table-001",
      "name": "Update Status in Table"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "run-status-check",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [240, 500],
      "id": "manual-trigger-001",
      "name": "Manual Trigger Webhook",
      "webhookId": "run-status-check-wh"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [[{ "node": "Read All Domains", "type": "main", "index": 0 }]]
    },
    "Read All Domains": {
      "main": [[{ "node": "Quick HTTP Check", "type": "main", "index": 0 }]]
    },
    "Quick HTTP Check": {
      "main": [[{ "node": "Update Status in Table", "type": "main", "index": 0 }]]
    },
    "Manual Trigger Webhook": {
      "main": [[{ "node": "Read All Domains", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}
